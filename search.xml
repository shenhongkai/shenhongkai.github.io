<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>iOS暗黑模式适配方案</title>
    <url>/2022/03/16/iOS%E6%9A%97%E5%A4%9C%E6%A8%A1%E5%BC%8F%E9%80%82%E9%85%8D%E5%AE%9E%E6%93%8D/</url>
    <content><![CDATA[<p>##iOS暗黑模式适配方案</p>
<h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>暗黑模式适配主要是考虑三个部分</p>
<ol>
<li>图片适配</li>
<li>颜色适配</li>
<li>封装基础组件用来监听暗黑模式的变化</li>
</ol>
<!---more---->

<h4 id="一、图片适配"><a href="#一、图片适配" class="headerlink" title="一、图片适配"></a>一、图片适配</h4><ul>
<li><p>使用ImageSet</p>
</li>
<li><p>打开Assets.xcassets</p>
</li>
<li><p>新建一个Image set  选择右边栏的Appearances中对应的选项适配深色模式。</p>
 <img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-25-1.png" width="60%" height="70%" class="alingleft">
</li>
<li><p>使用方法：[UIImage imageNamed:@”circle”];</p>
</li>
<li><p>当模式变化时,UIImage会动态的获取对应模式下的图片资源</p>
</li>
</ul>
<h4 id="二、颜色适配"><a href="#二、颜色适配" class="headerlink" title="二、颜色适配"></a>二、颜色适配</h4><ul>
<li><p>使用ColorSet</p>
</li>
<li><p>打开Assets.xcassets</p>
</li>
<li><p>新建一个Color set  选择右边栏的Appearances中对应的选项适配深色模式。</p>
<img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-25-2.png" width="60%" height="70%" class="alingleft">
</li>
<li><p>使用方法：<br>self.view.backgroundColor &#x3D; [UIColor colorNamed:@”testColor”]; </p>
</li>
<li><p>同样当模式发生变化时,UIColor会动态的获取对应模式下的颜色</p>
</li>
</ul>
<h4 id="三、封装基础组件用来监听暗黑模式的变化"><a href="#三、封装基础组件用来监听暗黑模式的变化" class="headerlink" title="三、封装基础组件用来监听暗黑模式的变化"></a>三、封装基础组件用来监听暗黑模式的变化</h4><p>监听暗黑模式的变化主要是封装系统监听方法,主要分两种监听,可以根据实际情况进行选择使用。</p>
<h5 id="一-为NSObject对象添加监听回调"><a href="#一-为NSObject对象添加监听回调" class="headerlink" title="(一)为NSObject对象添加监听回调"></a>(一)为NSObject对象添加监听回调</h5><ol>
<li>利用runtime为需要监听模式变化的obj对象添加一个监听模式变化的block回调,回调参数返回当前的模式标记</li>
<li>把该obj对象加入NSHashTable表中弱持有该对象</li>
<li>提前用runtime替换系统traitCollectionDidChange:方法,在替换的方法中判断当前暗黑模式是否发生改变以及当前的模式,然后在NSHashTable表中遍历每一个保存的obj对象,并且调用第一步中为之添加的block回调</li>
<li>obj对象可以在block带着模式参数回调回来后对obj对象进行适配操作,如下:<img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-25-3.png" width="60%" height="70%"></li>
</ol>
<h5 id="二-新建UIColor的分类监听模式的改变"><a href="#二-新建UIColor的分类监听模式的改变" class="headerlink" title="(二)新建UIColor的分类监听模式的改变"></a>(二)新建UIColor的分类监听模式的改变</h5><ol>
<li><p>建一个UIColor的分类,在分类中根据系统监听回调colorWithDynamicProvider:方法,进行颜色匹配,如下:</p>
  <img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-25-4.png" width="60%" height="70%">
</li>
<li><p>使用时:</p>
<img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-25-5.png" width="60%" height="70%"></li>
</ol>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>暗夜模式</tag>
      </tags>
  </entry>
  <entry>
    <title>iOS NSUInteger 运算问题</title>
    <url>/2022/03/21/iOS%20NSUInteger%20%E8%BF%90%E7%AE%97%E9%97%AE%E9%A2%98/</url>
    <content><![CDATA[<h2 id="iOS-NSUInteger-运算问题"><a href="#iOS-NSUInteger-运算问题" class="headerlink" title="iOS NSUInteger 运算问题"></a>iOS NSUInteger 运算问题</h2><h3 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h3><p>iOS中当NSUInteger参与运算时,一定要注意数值的取值范围。当表达式中存在有符号类型和无符号类型时全部的操做数都自动转换为无符号类型。</p>
<span id="more"></span>

<h3 id="正文"><a href="#正文" class="headerlink" title="正文"></a>正文</h3><p>例如在下面场景中,数组的count是无符号数据NSUInteger,遍历中idx的单位也是无符号数据NSUInteger。</p>
<figure class="highlight objc"><table><tr><td class="code"><pre><span class="line">  </span><br><span class="line"><span class="built_in">NSArray</span> *arr1 = @[<span class="string">@&quot;a&quot;</span>];</span><br><span class="line"><span class="built_in">NSArray</span> *arr2 = @[<span class="string">@&quot;1&quot;</span>,<span class="string">@&quot;2&quot;</span>,<span class="string">@&quot;3&quot;</span>];</span><br><span class="line"></span><br><span class="line">[arr2 enumerateObjectsUsingBlock:^(<span class="type">id</span>  _Nonnull obj, <span class="built_in">NSUInteger</span> idx, <span class="type">BOOL</span> * _Nonnull stop) &#123;</span><br><span class="line">    <span class="keyword">if</span> ((arr1.count-idx) &gt;= <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;大于等于0&quot;</span>);</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">NSLog</span>(<span class="string">@&quot;小于0&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">&#125;];</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>如果两者都是 NSInteger 有符号数据类型,那么arr1.count &#x3D; 1 , idx 分别为0,1,2, 所有(arr1.count-idx) 的值对应为1,0,-1, 所以打印结果应该为:</p>
<p>大于等于0</p>
<p>大于等于0</p>
<p>小于0</p>
<p>实际上,当arr1.count和idx的单位均为无符号数据NSUInteger时,打印结果为:<br><img src="https://raw.githubusercontent.com/shenhongkai/PicGo/main/2022-03-21-2.png" alt="2022-03-21-2"></p>
<p>从打印结果可以看到,当idx为2时,(arr1.count-idx)的结果以补码的方式转为了无符号类型的数值18446744073709551615。</p>
<h3 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h3><p>有符号NSUInteger数据类型参与运算时,一定要注意数值的取值范围不能是负数,当为表达式结果为负数时,会以补码的形式转换数值结果。</p>
]]></content>
      <categories>
        <category>iOS</category>
      </categories>
      <tags>
        <tag>小知识</tag>
      </tags>
  </entry>
</search>
